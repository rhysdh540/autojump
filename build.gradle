plugins {
	id "fabric-loom" version "1.5-SNAPSHOT"
	id "legacy-looming" version "1.5-SNAPSHOT"
}

base.archivesName = project.archives_base_name
version = project.mod_version
group = project.maven_group

loom {
	runs {
		remove server
	}
}

repositories {
	mavenCentral()
	flatDir { dirs "libs" }
	maven {
		url "https://jitpack.io"
		content {
			includeGroup("com.github.bawnorton.mixinsquared")
		}
	}
}

dependencies {
	minecraft "com.mojang:minecraft:${project.minecraft_version}"
	mappings(legacy.yarn(project.minecraft_version, project.yarn_build))
	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"
	modImplementation "net.legacyfabric.legacy-fabric-api:legacy-fabric-api:${project.fabric_version}"
	modCompileOnly("io.github.axolotlclient:AxolotlClient:3.0.6+1.8.9")
	modLocalRuntime(":legacy-modmenu-1.2.0+1.8.9-dev:")
	include(implementation(annotationProcessor("com.github.bawnorton.mixinsquared:mixinsquared-fabric:0.1.1")))
}

processResources {
	inputs.property "version", project.version

	filesMatching("fabric.mod.json") {
		expand "version": project.version
	}
}

tasks.withType(JavaCompile).configureEach {
	it.options.encoding = "UTF-8"

	if (JavaVersion.current().isJava9Compatible()) {
		it.options.release = 8
	}
}

java {
	sourceCompatibility = targetCompatibility = JavaVersion.VERSION_1_8
	withSourcesJar()
}

import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.tree.ClassNode

import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream
import java.util.zip.Deflater

remapJar {
	doLast {
		Map<String, byte[]> jarContents = [:]
		new JarFile(archiveFile.get().asFile as File).withCloseable {
			it.entries().each { entry ->
				jarContents[entry.name] = it.getInputStream(entry).bytes
			}
		}

		(archiveFile.get().asFile as File).delete()

		jarContents.removeAll {
			it.key.endsWith("refmap.json")
		}

		jarContents.replaceAll {name, bytes ->
			if(name.endsWith(".mixins.json")) {
				def json = new JsonSlurper().parseText(new String(bytes))
				json.remove("refmap")
			}
			if(name.endsWith(".json")) {
				return JsonOutput.toJson(new JsonSlurper().parse(bytes)).bytes
			}

			if(name.endsWith(".class") && strip_lvt.toBoolean()) {
				ClassNode classNode = new ClassNode()
				new ClassReader(bytes).accept(classNode, 0)

				classNode.methods.forEach {
					it.parameters?.clear()
					it.localVariables?.clear()
				}

				ClassWriter writer = new ClassWriter(0)
				classNode.accept(writer)
				return writer.toByteArray()
			}
			return bytes
		}

		new JarOutputStream(new FileOutputStream(archiveFile.get().asFile as File)).withCloseable {
			it.setLevel(Deflater.BEST_COMPRESSION)
			jarContents.each { name, bytes ->
				it.putNextEntry(new JarEntry(name))
				it.write(bytes)
				it.closeEntry()
			}
			it.finish()
		}
	}
}
